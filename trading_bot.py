import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import logging
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import warnings
import random
warnings.filterwarnings('ignore')

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

class TradingStrategy(Enum):
    CONSERVATIVE = "ูุญุงูุธ"
    MODERATE = "ูุณุชูุฑ" 
    AGGRESSIVE = "ุนุฏูุงูู"

@dataclass
class TradingConfig:
    """ุฅุนุฏุงุฏุงุช ุงูุชุฏุงูู ุงููุญุณูุฉ"""
    initial_capital: float = 1000.0
    risk_per_trade: float = 0.02
    max_position_size: float = 0.3
    selected_pairs: List[str] = None
    strategy: TradingStrategy = TradingStrategy.MODERATE
    min_trade_amount: float = 5.0  # ุญุฏ ุฃุฏูู ููุตููุฉ
    
    def __post_init__(self):
        if self.selected_pairs is None:
            self.selected_pairs = ["BTCUSDT", "ETHUSDT", "BNBUSDT"]

class ImprovedTradingBot:
    """
    ุจูุช ุชุฏุงูู ูุญุณู ูุน ุฑุจุญ ุชุฑุงููู ููุฑู ูุฏุนู ูููุจุงูุบ ุงูุตุบูุฑุฉ
    """
    
    def __init__(self, config: TradingConfig):
        self.config = config
        self.initial_balance = config.initial_capital
        self.current_balance = config.initial_capital
        self.positions = {}
        self.trade_history = []
        
        # ุฅุญุตุงุฆูุงุช ูุญุณูุฉ
        self.real_time_stats = {
            'total_trades': 0,
            'winning_trades': 0,
            'losing_trades': 0,
            'total_profit': 0.0,
            'max_drawdown': 0.0,
            'current_streak': 0,
            'max_win_streak': 0,
            'max_loss_streak': 0,
            'compounded_growth': 0.0,
            'equity_curve': [config.initial_capital],
            'consecutive_losses': 0
        }
        
        logger.info(f"๐ ุงูุจูุช ุงููุญุณู ุฌุงูุฒ | ุงูุฑุตูุฏ: ${self.current_balance:.2f}")
    
    def calculate_advanced_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """ูุคุดุฑุงุช ูููุฉ ูุชูุฏูุฉ ุจุฏูุฉ ุฃุนูู"""
        df = df.copy()
        
        # ุงููุชูุณุทุงุช ุงููุชุญุฑูุฉ ูุชุนุฏุฏุฉ ุงููุชุฑุงุช
        for period in [5, 10, 20, 50]:
            df[f'sma_{period}'] = df['close'].rolling(period).mean()
            df[f'ema_{period}'] = df['close'].ewm(span=period).mean()
        
        # RSI ูุชุนุฏุฏ ุงููุชุฑุงุช
        for period in [7, 14]:
            delta = df['close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(period).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(period).mean()
            rs = gain / loss
            df[f'rsi_{period}'] = 100 - (100 / (1 + rs))
        
        # MACD ูุชูุฏู
        df['macd'] = df['ema_12'] - df['ema_26']
        df['macd_signal'] = df['macd'].ewm(span=9).mean()
        df['macd_hist'] = df['macd'] - df['macd_signal']
        
        # ุจูููุฌุฑ ุจุงูุฏุฒ ูุชุนุฏุฏ ุงููุณุชููุงุช
        for period in [20]:
            df[f'bb_middle_{period}'] = df['close'].rolling(period).mean()
            bb_std = df['close'].rolling(period).std()
            df[f'bb_upper_{period}'] = df[f'bb_middle_{period}'] + (bb_std * 2)
            df[f'bb_lower_{period}'] = df[f'bb_middle_{period}'] - (bb_std * 2)
            df[f'bb_width_{period}'] = (df[f'bb_upper_{period}'] - df[f'bb_lower_{period}']) / df[f'bb_middle_{period}']
        
        # ูุคุดุฑ ุงูููุฉ ุงููุณุจูุฉ ุงููุฒูู
        df['weighted_rsi'] = (df['rsi_7'] * 0.3 + df['rsi_14'] * 0.7)
        
        # ุงุชุฌุงู ููู
        df['strong_trend_up'] = (df['ema_5'] > df['ema_10']) & (df['ema_10'] > df['ema_20']) & (df['ema_20'] > df['ema_50'])
        df['strong_trend_down'] = (df['ema_5'] < df['ema_10']) & (df['ema_10'] < df['ema_20']) & (df['ema_20'] < df['ema_50'])
        
        # ุชููุจุงุช ุงูุณูู
        df['volatility'] = df['close'].rolling(20).std() / df['close'].rolling(20).mean()
        
        # ุญุฌู ุงูุชุฏุงูู ุงููุณุจู
        df['volume_ma'] = df['volume'].rolling(20).mean()
        df['volume_ratio'] = df['volume'] / df['volume_ma']
        
        return df
    
    def generate_intelligent_signals(self, df: pd.DataFrame) -> pd.DataFrame:
        """ุฅุดุงุฑุงุช ุชุฏุงูู ุฐููุฉ ุจุฏูุฉ ุนุงููุฉ"""
        df = df.copy()
        
        # ูุธุงู ุชุตููุช ูุชูุฏู
        df['buy_score'] = 0
        df['sell_score'] = 0
        
        # ุดุฑูุท ุงูุดุฑุงุก ุงููููุฉ (3 ููุงุท)
        df.loc[df['strong_trend_up'], 'buy_score'] += 3
        df.loc[df['weighted_rsi'] < 35, 'buy_score'] += 2
        df.loc[df['macd_hist'] > 0, 'buy_score'] += 2
        df.loc[df['close'] < df['bb_lower_20'], 'buy_score'] += 2
        df.loc[df['volume_ratio'] > 1.5, 'buy_score'] += 1
        
        # ุดุฑูุท ุงูุจูุน ุงููููุฉ (3 ููุงุท)
        df.loc[df['strong_trend_down'], 'sell_score'] += 3
        df.loc[df['weighted_rsi'] > 65, 'sell_score'] += 2
        df.loc[df['macd_hist'] < 0, 'sell_score'] += 2
        df.loc[df['close'] > df['bb_upper_20'], 'sell_score'] += 2
        df.loc[df['volume_ratio'] > 1.5, 'sell_score'] += 1
        
        # ุดุฑูุท ุฅุถุงููุฉ ูุชุญุณูู ุงูุฏูุฉ
        df['momentum'] = df['close'] / df['close'].shift(5) - 1
        df.loc[df['momentum'] > 0.02, 'buy_score'] += 1
        df.loc[df['momentum'] < -0.02, 'sell_score'] += 1
        
        # ูุฑุงุฑุงุช ุงูุชุฏุงูู ุงูุฐููุฉ
        df['buy_signal'] = df['buy_score'] >= 6  # ุนุชุจุฉ ุนุงููุฉ ููุดุฑุงุก
        df['sell_signal'] = df['sell_score'] >= 6  # ุนุชุจุฉ ุนุงููุฉ ููุจูุน
        
        # ุชุตููุฉ ุงูุฅุดุงุฑุงุช ุงูุถุนููุฉ
        df['signal_strength'] = df['buy_score'] - df['sell_score']
        df['strong_buy'] = (df['buy_signal'] & (df['signal_strength'] >= 3))
        df['strong_sell'] = (df['sell_signal'] & (df['signal_strength'] <= -3))
        
        return df
    
    def calculate_smart_position_size(self, current_price: float, confidence: float, symbol: str) -> float:
        """ุญุฌู ูุฑูุฒ ุฐูู ูุน ุฏุนู ูููุจุงูุบ ุงูุตุบูุฑุฉ"""
        # ุชูููู ุงููุฎุงุทุฑุฉ ุจูุงุกู ุนูู ุงูุฃุฏุงุก
        base_risk = self.config.risk_per_trade
        
        # ุชูููู ุงููุฎุงุทุฑุฉ ุจุนุฏ ุงูุฎุณุงุฆุฑ ุงููุชุชุงููุฉ
        if self.real_time_stats['consecutive_losses'] >= 2:
            base_risk *= 0.5
        
        # ุฒูุงุฏุฉ ุงููุฎุงุทุฑุฉ ุจุนุฏ ุงูุฃุฑุจุงุญ ุงููุชุชุงููุฉ
        if self.real_time_stats['current_streak'] >= 2:
            base_risk = min(base_risk * 1.3, 0.05)  # ุญุฏ ุฃูุตู 5%
        
        # ุชูููู ูุน ุญุฌู ุฑุฃุณ ุงููุงู
        if self.current_balance < 50:
            min_trade = max(1.0, self.current_balance * 0.1)  # 10% ูุญุฏ ุฃุฏูู ููุตููุงุช ุงูุตุบูุฑุฉ
        else:
            min_trade = self.config.min_trade_amount
        
        # ุญุณุงุจ ุญุฌู ุงููุฑูุฒ
        risk_amount = self.current_balance * base_risk * confidence
        position_value = max(risk_amount * 1.5, min_trade)  # ุฑุงูุนุฉ ูุญุงูุธุฉ
        
        # ุนุฏู ุชุฌุงูุฒ ุงูุญุฏ ุงูุฃูุตู
        max_position_value = self.current_balance * self.config.max_position_size
        position_value = min(position_value, max_position_value)
        
        # ุญุณุงุจ ุงููููุฉ
        quantity = position_value / current_price if current_price > 0 else 0
        
        # ุชูุฑูุจ ูู 4 ููุงุฒู ุนุดุฑูุฉ ููุนููุงุช ุงูุฑูููุฉ
        quantity = round(quantity, 6)
        
        return quantity
    
    def execute_improved_compounding(self, profit: float, trade_info: Dict):
        """ูุธุงู ุฑุจุญ ุชุฑุงููู ูุญุณู"""
        old_balance = self.current_balance
        self.current_balance += profit
        
        # ุชุญุฏูุซ ุงูุฅุญุตุงุฆูุงุช
        self.real_time_stats['total_profit'] += profit
        self.real_time_stats['total_trades'] += 1
        
        if profit > 0:
            self.real_time_stats['winning_trades'] += 1
            self.real_time_stats['current_streak'] = max(self.real_time_stats['current_streak'] + 1, 0)
            self.real_time_stats['max_win_streak'] = max(
                self.real_time_stats['max_win_streak'],
                self.real_time_stats['current_streak']
            )
            self.real_time_stats['consecutive_losses'] = 0
            
            # ููู ุชุฑุงููู ูุญุณู
            growth_rate = profit / old_balance
            self.real_time_stats['compounded_growth'] = (
                (1 + self.real_time_stats['compounded_growth']) * (1 + growth_rate) - 1
            )
            
            logger.info(f"๐ฐ ุฑุจุญ ุชุฑุงููู: +${profit:.4f} | ุงูุฑุตูุฏ: ${self.current_balance:.4f}")
        else:
            self.real_time_stats['losing_trades'] += 1
            self.real_time_stats['current_streak'] = min(self.real_time_stats['current_streak'] - 1, 0)
            self.real_time_stats['consecutive_losses'] += 1
            self.real_time_stats['max_loss_streak'] = min(
                self.real_time_stats['max_loss_streak'],
                self.real_time_stats['current_streak']
            )
        
        # ุชุญุฏูุซ ููุญูู ุฑุฃุณ ุงููุงู
        self.real_time_stats['equity_curve'].append(self.current_balance)
        
        # ุชุญุฏูุซ ุฃูุตู ุฎุณุงุฑุฉ
        peak = max(self.real_time_stats['equity_curve'])
        current_drawdown = (peak - self.current_balance) / peak * 100
        self.real_time_stats['max_drawdown'] = max(
            self.real_time_stats['max_drawdown'],
            current_drawdown
        )
    
    def should_enter_trade(self, symbol: str, row, current_price: float) -> bool:
        """ุชุญุฏูุฏ ุฅุฐุง ูุงู ูุฌุจ ุงูุฏุฎูู ูู ุตููุฉ"""
        # ุนุฏู ุงูุฏุฎูู ุฅุฐุง ูุงู ุงูุฑุตูุฏ ุบูุฑ ูุงูู
        if self.current_balance < 1.0:
            return False
        
        # ุนุฏู ุงูุฏุฎูู ุฅุฐุง ูุงู ููุงู ุตููุฉ ููุชูุญุฉ ูู ููุณ ุงูุฒูุฌ
        if symbol in self.positions:
            return False
        
        # ุงูุฏุฎูู ููุท ูู ุงูุฅุดุงุฑุงุช ุงููููุฉ
        if not row.get('strong_buy', False):
            return False
        
        # ุชุฌูุจ ุงูุชุฏุงูู ูู ุธุฑูู ุงูุชููุจ ุงูุนุงูู
        if row.get('volatility', 0) > 0.05:  # ุชุฌูุจ ุงูุชููุจ ููู 5%
            return False
        
        return True
    
    def run_improved_backtest(self, market_data: Dict, symbols: List[str]) -> Dict:
        """ูุญุงูุงุฉ ูุญุณูุฉ ูุน ูุชุงุฆุฌ ุฃูุถู"""
        results = {}
        
        logger.info(f"๐ฏ ุจุฏุก ุงููุญุงูุงุฉ ุงููุญุณูุฉ ุนูู {len(symbols)} ุนููุงุช")
        
        for symbol in symbols:
            if symbol not in market_data:
                continue
                
            logger.info(f"๐ ุชุญููู {symbol}...")
            df = market_data[symbol].copy()
            
            # ุญุณุงุจ ุงููุคุดุฑุงุช ุงููุชูุฏูุฉ
            df = self.calculate_advanced_indicators(df)
            df = self.generate_intelligent_signals(df)
            
            symbol_trades = []
            
            for i, (timestamp, row) in enumerate(df.iterrows()):
                if i < 50:  # ุชุฃูุฏ ูู ูุฌูุฏ ุจูุงูุงุช ูุงููุฉ
                    continue
                    
                current_price = row['close']
                atr_value = row.get('volatility', 0.02) * current_price
                
                # ุงูุฏุฎูู ูู ุตููุฉ ุดุฑุงุก
                if self.should_enter_trade(symbol, row, current_price):
                    confidence = min(1.0, row['buy_score'] / 10.0)
                    quantity = self.calculate_smart_position_size(current_price, confidence, symbol)
                    
                    if quantity * current_price >= 1.0:  # ุตููุฉ ุฐุงุช ุญุฌู ูุนููู
                        # ููู ุฎุณุงุฑุฉ ูุฌูู ุฃุฑุจุงุญ ุฐูู
                        stop_loss = current_price * 0.98  # 2% ููู ุฎุณุงุฑุฉ
                        take_profit = current_price * 1.04  # 4% ุฌูู ุฃุฑุจุงุญ
                        
                        self.positions[symbol] = {
                            'entry_time': timestamp,
                            'entry_price': current_price,
                            'quantity': quantity,
                            'investment': quantity * current_price,
                            'stop_loss': stop_loss,
                            'take_profit': take_profit,
                            'type': 'LONG',
                            'confidence': confidence
                        }
                        
                        # ุฎุตู ุงููุจูุบ ูู ุงูุฑุตูุฏ
                        self.current_balance -= quantity * current_price
                        
                        trade_record = {
                            'symbol': symbol,
                            'action': 'BUY',
                            'timestamp': timestamp,
                            'price': current_price,
                            'quantity': quantity,
                            'amount': quantity * current_price,
                            'confidence': confidence,
                            'status': 'OPEN'
                        }
                        
                        symbol_trades.append(trade_record)
                        self.trade_history.append(trade_record)
                
                # ุฅุบูุงู ุงูุตููุงุช
                elif symbol in self.positions:
                    position = self.positions[symbol]
                    
                    # ุดุฑูุท ุงูุฅุบูุงู ุงููุญุณูุฉ
                    close_trade = False
                    close_reason = ""
                    exit_price = current_price
                    
                    if row.get('strong_sell', False):
                        close_trade = True
                        close_reason = "ุฅุดุงุฑุฉ ุจูุน ูููุฉ"
                    elif current_price <= position['stop_loss']:
                        close_trade = True
                        close_reason = "ููู ุฎุณุงุฑุฉ"
                        exit_price = position['stop_loss']
                    elif current_price >= position['take_profit']:
                        close_trade = True
                        close_reason = "ุฌูู ุฃุฑุจุงุญ"
                        exit_price = position['take_profit']
                    # ุฅุบูุงู ุจุนุฏ ูุชุฑุฉ ุฒูููุฉ (5 ูุชุฑุงุช)
                    elif len([t for t in symbol_trades if t.get('symbol') == symbol and t.get('status') == 'OPEN']) >= 5:
                        close_trade = True
                        close_reason = "ุฅุบูุงู ุฒููู"
                    
                    if close_trade:
                        profit = (exit_price - position['entry_price']) * position['quantity']
                        
                        # ุชุทุจูู ุงูุฑุจุญ ุงูุชุฑุงููู ุงููุญุณู
                        self.execute_improved_compounding(profit, {
                            'symbol': symbol,
                            'position': position,
                            'exit_price': exit_price,
                            'reason': close_reason
                        })
                        
                        # ุชุณุฌูู ุงูุตููุฉ ุงููุบููุฉ
                        trade_record = {
                            'symbol': symbol,
                            'action': 'SELL',
                            'timestamp': timestamp,
                            'price': exit_price,
                            'quantity': position['quantity'],
                            'amount': position['investment'],
                            'profit': profit,
                            'profit_pct': (profit / position['investment']) * 100,
                            'status': 'CLOSED',
                            'close_reason': close_reason,
                            'confidence': position['confidence']
                        }
                        
                        symbol_trades.append(trade_record)
                        self.trade_history.append(trade_record)
                        
                        # ุฅุฒุงูุฉ ุงููุฑูุฒ
                        del self.positions[symbol]
            
            results[symbol] = {
                'trades': symbol_trades,
                'total_trades': len([t for t in symbol_trades if t.get('status') == 'CLOSED']),
                'profitable_trades': len([t for t in symbol_trades if t.get('profit', 0) > 0])
            }
        
        # ุญุณุงุจ ุงูููุงููุณ ุงูููุงุฆูุฉ ุงููุญุณูุฉ
        return self.calculate_improved_metrics()
    
    def calculate_improved_metrics(self) -> Dict:
        """ุญุณุงุจ ููุงููุณ ุฃุฏุงุก ูุญุณูุฉ"""
        total_profit = self.current_balance - self.initial_balance
        total_return = (total_profit / self.initial_balance) * 100
        
        closed_trades = [t for t in self.trade_history if t.get('status') == 'CLOSED']
        winning_trades = [t for t in closed_trades if t.get('profit', 0) > 0]
        win_rate = (len(winning_trades) / len(closed_trades)) * 100 if closed_trades else 0
        
        # ุญุณุงุจ ุนุงูู ุงูุฑุจุญ
        gross_profit = sum(t.get('profit', 0) for t in winning_trades)
        gross_loss = abs(sum(t.get('profit', 0) for t in closed_trades if t.get('profit', 0) < 0))
        profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
        
        # ูุชูุณุท ุงูุฑุจุญ ูุชุญุณููู
        avg_profit = np.mean([t.get('profit', 0) for t in closed_trades]) if closed_trades else 0
        avg_win = np.mean([t.get('profit', 0) for t in winning_trades]) if winning_trades else 0
        avg_loss = np.mean([t.get('profit', 0) for t in closed_trades if t.get('profit', 0) < 0]) if len(closed_trades) > len(winning_trades) else 0
        
        # ูุณุจุฉ ุงูุนุงุฆุฏ ุฅูู ุงููุฎุงุทุฑุฉ
        risk_reward_ratio = abs(avg_win / avg_loss) if avg_loss != 0 else 0
        
        # ุชูููู ุงูุฃุฏุงุก
        performance_score = self.calculate_performance_score(win_rate, profit_factor, total_return)
        
        final_metrics = {
            'initial_balance': self.initial_balance,
            'final_balance': self.current_balance,
            'total_profit': total_profit,
            'total_return': total_return,
            'total_trades': len(closed_trades),
            'winning_trades': len(winning_trades),
            'losing_trades': len(closed_trades) - len(winning_trades),
            'win_rate': win_rate,
            'max_drawdown': self.real_time_stats['max_drawdown'],
            'compounded_growth': self.real_time_stats['compounded_growth'] * 100,
            'profit_factor': profit_factor,
            'avg_profit': avg_profit,
            'avg_win': avg_win,
            'avg_loss': avg_loss,
            'risk_reward_ratio': risk_reward_ratio,
            'performance_score': performance_score,
            'current_streak': self.real_time_stats['current_streak']
        }
        
        logger.info(f"๐ ุงูุชูุช ุงููุญุงูุงุฉ | ุงูุฑุจุญ: ${total_profit:.2f} ({total_return:.2f}%) | ุงููุฌุงุญ: {win_rate:.1f}%")
        
        return {
            'symbol_results': {},
            'performance_metrics': final_metrics,
            'trade_history': self.trade_history,
            'equity_curve': self.real_time_stats['equity_curve']
        }
    
    def calculate_performance_score(self, win_rate: float, profit_factor: float, total_return: float) -> float:
        """ุญุณุงุจ ุชูููู ุฃุฏุงุก ุดุงูู"""
        score = 0
        
        # ูุฒู ูุนุฏู ุงููุฌุงุญ (40%)
        if win_rate >= 70:
            score += 40
        elif win_rate >= 60:
            score += 30
        elif win_rate >= 50:
            score += 20
        elif win_rate >= 40:
            score += 10
        
        # ูุฒู ุนุงูู ุงูุฑุจุญ (30%)
        if profit_factor >= 2.0:
            score += 30
        elif profit_factor >= 1.5:
            score += 25
        elif profit_factor >= 1.2:
            score += 20
        elif profit_factor >= 1.0:
            score += 15
        elif profit_factor >= 0.8:
            score += 10
        
        # ูุฒู ุงูุนุงุฆุฏ ุงูููู (30%)
        if total_return >= 50:
            score += 30
        elif total_return >= 30:
            score += 25
        elif total_return >= 20:
            score += 20
        elif total_return >= 10:
            score += 15
        elif total_return >= 0:
            score += 10
        elif total_return >= -10:
            score += 5
        
        return min(100, score)
